## 取り組んだ課題一覧
- reactチュートリアルまで

## わかったこと
- **state ロジックをリデューサに抽出する**
  - 多くのイベントハンドラにまたがって state の更新コードがあると理解が難しくなる
  - 外部に「リデューサ関数」を作成し、state 更新ロジックを集約できる
  - useState → useReducer への移行手順
    1. state セットをアクションのディスパッチに置き換える
    2. リデューサ関数を作成する
    3. コンポーネントからリデューサを使用する
  - ポイント
    - 「tasks をセットする」のではなく「タスクを追加/変更/削除した」というアクションをディスパッチする
    - アクションオブジェクトは `type` を必須にして説明的な名前をつける

- **リデューサ関数**
  - 現在の state とアクションオブジェクトを引数に取り、次の state を返す
  - switch 文を使うことが一般的
  - case ブロックは `{ }` で囲み return を忘れない
  - 名前の由来は「配列の reduce 操作」

- **useState と useReducer の比較**
  - コード量
    - useState の方が初期は少ない
    - useReducer は複数のイベントハンドラで同じロジックを扱う場合に有利
  - 可読性
    - useState はシンプル
    - useReducer は複雑さを分離できる
  - デバッグ
    - useReducer はすべてのアクションを追跡できる
  - テスト
    - リデューサは純関数なので単体テストが容易
  - 好みで使い分け可能

- **リデューサの注意点**
  - 純粋関数であること（副作用を持たない）
  - 複数の更新をまとめて「単一のアクション」にする
  - Immer を使うとミューテーション風に書ける
  - `alert` などの副作用はリデューサに書かない

- **STATE の管理**
  - **コンテクストで深くデータを受け渡す**
    - props の穴掘り（prop drilling）を解消する
    - props を使わずにツリー全体へ値を共有できる
    - 手順
      1. コンテクストを作成する
      2. コンポーネントで useContext を使用する
      3. コンテクストを提供するコンポーネントで Provider を使う
    - CSS の継承のように上書き可能
  - **コンテクストの用途**
    - テーマ（ダークモードなど）
    - 現在のアカウント情報
    - ルーティング
    - state 管理
  - **検討すべき代替案**
    - まずは props を渡す
    - children を使って構造を簡略化する

- **リデューサとコンテクストを組み合わせる**
  - state と dispatch をコンテクストに入れて渡す
  - 任意のコンポーネントが上位 state を読み取り・更新可能
  - TasksProvider のようなまとめ用コンポーネントを用意する
  - useTasks / useTasksDispatch などのカスタムフックでアクセスを簡単にする

- **ref**
  - レンダーに使わない値を保持する「避難ハッチ」
  - 特徴
    - `useRef(initialValue)` → `{ current: initialValue }` を返す
    - 変更しても再レンダーされない
    - state と違いミュータブル
  - 使用場面
    - タイムアウト ID 保存
    - DOM 要素へのアクセス
    - JSX に影響しないオブジェクト保持
  - ベストプラクティス
    - escape hatch として使う
    - レンダー中に `ref.current` を操作しない

- **ref で DOM を操作する**
  - 手順
    ```js
    import { useRef } from 'react';
    const myRef = useRef(null);
    <div ref={myRef}></div>
    ```
  - React が commit フェーズで DOM ノードを ref に割り当てる
  - 注意
    - React 管理下の DOM を直接書き換えない
    - 安全な場合のみ変更する（常に空の div に追加など）

- **エフェクト (Effect)**
  - 外部システムとの同期に使う
  - 特徴
    - イベントではなく「レンダーによって発生」
    - useEffect を使う
    - 依存配列を正しく指定する
    - クリーンアップを返す
  - 書き方のステップ
    1. 宣言する
    2. 依存配列を指定する
    3. 必要に応じてクリーンアップする
  - 注意
    - 不要なエフェクトは避ける（計算で済むなら state へ）
    - fetch を直接エフェクトに書くと非効率になりやすい
    - Strict Mode では開発中のみ2回実行される

- **エフェクトのベストプラクティス**
  - 不要な依存を避ける
  - 依存配列はコードに必ず一致させる
  - 複数の処理はエフェクトを分割する
  - 非リアクティブな処理は useEffectEvent に抽出する

- **カスタムフック**
  - 複数コンポーネント間でロジックを共有する仕組み
  - 特徴
    - 名前は `use` で始める
    - state ではなく「ロジック」を共有
    - 純粋関数である必要がある
  - 利点
    - 外部システムとの同期を隠蔽できる
    - 意図がわかりやすい API にできる
    - コンポーネントの責務を減らせる
  - 命名例
    - ✅ useData(url)
    - ✅ useChatRoom(options)
    - 🔴 useMount(fn) のような抽象的なものは避ける



## 感じたこと    
- reacチュートリアルはかなり難しく感じた。とりあえず慣れるしかないと思うので、課題を進めて慣れていきたい                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                             
                                    
## 学習時間
- 本日：6h
- 合計：520.5h
## 取り組んだ課題一覧
- JavaScript Primmer

## わかったこと
- 文字列リテラルとエスケープシーケンス
    - 文字列リテラルには、`"`（ダブルクォート）、`'`（シングルクォート）、`` ` ``（バッククォート）の3種類があります。
    - `"` と `'` に意味的な違いはありません。
    - ES2015では、**テンプレートリテラル `` ` ``（バッククォート）**が追加されました。
    - 文字列リテラルは同じ記号が対になります。文字列の中にリテラルと同じ記号が出現した場合は、`\`（バックスラッシュ）を使ってエスケープする必要があります。
    - 改行のような特殊な文字はエスケープシーケンスとして書きます。エスケープシーケンスは `\` と特定の文字を組み合わせることで、特殊文字を表現します。

- 代表的なエスケープシーケンス

| エスケープシーケンス | 意味 |
|------------------|------|
| `\'`  | シングルクォート |
| `\"`  | ダブルクォート |
| `` \` `` | バッククォート |
| `\\`  | バックスラッシュ |
| `\n`  | 改行 |
| `\t`  | タブ |
| `\uXXXX` | Code Unit（`\u`と4桁のHexDigit） |
| `\u{X} ... \u{XXXXXX}` | Code Point（`\u{}`のカッコ中にHexDigit） |

- 文字列の操作とプロパティ
    - 文字列を結合する簡単な方法は **文字列結合演算子（+）** を使う方法です。
    - 特定の書式に文字列を埋め込むには、テンプレートリテラルを使い、`${変数名}` で変数を展開します。
    - `文字列[インデックス]` のように指定した位置の文字へアクセスできます（インデックスは `0` 以上 `2^53 - 1` 未満の整数）。
    - ES2022から、相対的なインデックスを渡せる **String.prototype.at** メソッドが追加されました。
    - JavaScriptにおける文字列は、16ビットのCode Unitが順番に並んだものとして内部的に管理されています。
    - 文字列を配列へ分解するには **String.split** メソッドを、配列を文字列にするには **Array.join** メソッドを利用します。
    - 文字列の比較には **`===`（厳密比較演算子）** を利用します。
    - 文字列からCode Unitの数値を取得するには、**String.charCodeAt** メソッドを利用します。
- 文字列の検索と切り出し
    - 文字列の切り出しには **String.slice** メソッドと **String.substring** メソッドがあります。
      - **slice**: 第一引数から第二引数（含まない）までの範囲を返す。
      - **substring**: slice と似ていますが、マイナスの値は `0` として扱われ、引数の位置が入れ替わる違いがあります。
    - 文字列の検索方法には、文字列による検索と正規表現による検索があります。
    - **String.indexOf / String.lastIndexOf**: 指定した文字列が最初に（最後に）現れたインデックスを返す。
    - ES2015で追加された検索メソッド
      - `String.prototype.startsWith(検索文字列)`
      - `String.prototype.endsWith(検索文字列)`
      - `String.prototype.includes(検索文字列)`
- 正規表現
    - 正規表現は **正規表現オブジェクト（RegExpオブジェクト）** として表現されます。
    - 正規表現のパターン内では、`\ ^ $ . * + ? ( ) [ ] { } |` は特殊文字として扱われます。
    - 正規表現リテラルと **RegExpコンストラクタ** には、パターンが評価されるタイミングの違いがあります。
- 正規表現を使うメソッド
    - **String.search** → マッチした箇所のインデックスを返す。
    - **String.match** → マッチした文字列に関する情報を返す。
      - gフラグなし → 最初にマッチした情報のみ
      - gフラグあり → マッチしたすべての結果を配列で返す
    - ES2020から **String.matchAll** が追加され、gフラグでの繰り返しマッチに対してIteratorを返す。
-  キャプチャリング
    - `/(パターン1)(パターン2)/` のように括弧で囲んだ部分を取り出すことができる。
-  文字列の置換と削除
    - 文字列の一部を置換・削除するには **String.replace** メソッドを利用。
      - `replace` は最初に一致したものだけを置換。
      - `replaceAll` は一致したものをすべて置換。
      - 第二引数にはコールバック関数を渡すことも可能。
- テンプレートリテラルとUnicode
    - タグつきテンプレート関数は `` 関数テンプレート` `` という形式で記述。
    - Unicodeは全ての文字に対してIDを定義する仕様。このIDを **Code Point（符号位置）** と呼ぶ。
    - サロゲートペアは、2つのCode Unit（4バイト）で1つのCode Pointを表す。
    - `String.length` は Code Unit の個数を返す。
    - **Array.from** を使うと Code Point ごとに分解できる。
- ラッパーオブジェクト
    - 真偽値、数値、BigInt、文字列、シンボルにはそれぞれ対応するラッパーオブジェクトが存在。
    - `new String("string")` のようにしてインスタンスを作れる。
    - プリミティブ型の値にプロパティアクセスすると、自動でラッパーオブジェクトに変換される。
    - **valueOf** メソッドで値を取り出せる。
    - 常にリテラルを使うことが推奨される。
- スコープと巻き上げ
    - **スコープ** = 変数や関数の参照できる範囲。
      - ブロックスコープ → `{}` 単位
      - 関数スコープ → 関数ごと
      - グローバルスコープ → 最も外側
    - スコープチェーン: 内側から外側に向かって変数を探索。
    - 変数の隠蔽（shadowing）: 内側のスコープで同名変数を定義すると外側が見えなくなる。
    - 巻き上げ（hoisting）: `var` や `function` 宣言がスコープの先頭に移動したように見える動作。
    - **即時実行関数（IIFE）**: グローバル汚染を避けるイディオム。
- クロージャーとthis
    - **クロージャー**: 外側のスコープの変数を保持できる性質。
    - **静的スコープ**: 参照関係を静的に決定する性質。
    - **this** の参照先は実行コンテキストや呼び出し方によって変化。
    - Script 実行コンテキスト → `this` はグローバルオブジェクト
    - Module 実行コンテキスト → `this` は `undefined`
    - **globalThis** → 実行環境のグローバルオブジェクトを参照
    - メソッドにおける `this` → 呼び出し元のオブジェクト
    - `this` は定義時ではなく実行時に決定
    - **Functionオブジェクト** → `call`, `apply`, `bind` で this を明示的に指定可能
    - **Arrow Function** → this を受け取らず外側をそのまま利用
- クラス
    - **class構文** は ES2015で導入。クラスは関数オブジェクトの一種。
    - **constructor**: インスタンス作成時に自動実行される。
    - **new演算子** でインスタンス化。
    - **instanceof演算子** → クラスのインスタンス判定。
    - メソッドはプロトタイプメソッドとしてインスタンス間で共有される。
- プロパティ
    - アクセッサプロパティ（getter/setter）
    - ES2022: Privateクラスフィールド（`#`付き）
    - Publicクラスフィールド
    - 静的メソッド（`static`）と静的クラスフィールド
- 継承
    - **extends** → クラス継承
    - **super** → 親クラスの参照
    - 子クラスは `this` 使用前に `super()` を呼ぶ必要がある
    - プロトタイプチェーンで継承を実現
    - **instanceof** で継承関係を判定可能
- 例外処理
    - **try...catch** → 例外処理
    - **finally** → 必ず実行される処理
    - **throw** → 例外を投げる（`Error` オブジェクト推奨）
    - ビルトインエラー例: `ReferenceError`, `SyntaxError`, `TypeError`
    - ES2022: `Error` に **causeオプション** が追加
- 非同期処理
    - **同期処理**: 1つずつ順番に実行
    - **非同期処理**: 終了を待たずに次の処理へ
-  Promise
    - ES2015で導入
    - `new Promise((resolve, reject) => {...})`
    - `then` → 成功時
    - `catch` → 失敗時
    - **Promiseチェーン**: then/catch で順に処理をつなぐ
    - **Promise.all**: 全てのPromise完了を待つ
    - **Promise.race**: 最初に完了した結果を返す
-  Async/Await
    - ES2017で導入
    - `async function` → 必ずPromiseを返す
    - `await` → Promiseの完了を待つ
    - **Top-Level await**（ES2022） → モジュールのトップレベルでも利用可
-  コールバック
    - **エラーファーストコールバック**: コールバックの最初の引数にエラーを渡すルール


## 次やること
- JavaScript Primmer

## 感じたこと    
- JavaScript Primmerが徐々に難しくなってきて、知らない知識が増えてきたので、何回か読み直したいと思います                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                                                                             
                                    
## 学習時間
- 本日：4.5h
- 合計：452.75h
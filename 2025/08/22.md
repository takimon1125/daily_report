# JavaScript オブジェクトと配列の仕組み

- プロトタイプとビルトインメソッド
  - オブジェクトに組み込まれたメソッドを **ビルトインメソッド** と呼ぶ  
  - 他のオブジェクトはすべて `Object` を継承している  
  - ほとんどすべてのオブジェクトは `Object.prototype` に定義された **prototypeオブジェクト** を継承  
  - prototypeオブジェクトとは、オブジェクト作成時に自動的に追加される特殊なオブジェクト  
  - **プロトタイプメソッド**: prototypeオブジェクトに組み込まれているメソッド  
  - **プロトタイプチェーン**: prototypeオブジェクト上に定義されたメソッドを参照する仕組み  
  - インスタンスとprototypeオブジェクトで同じ名前のメソッドがある場合 → インスタンスのメソッドが優先される  

- Object関連のメソッド
  - `Object.hasOwn(obj, prop)` : オブジェクト自身がプロパティを持っているか判定  
  - `in` 演算子 : prototypeチェーンも探索する  
  - `Object.create(proto)` : 指定したprototypeオブジェクトを継承したオブジェクトを作成  
  - `Object.create(null)` : `Object.prototype` を継承しない空のオブジェクトを作成  

- 配列の基本
  - 配列は順序付きで値を格納できるオブジェクト  
  - 要素の位置は **インデックス**（0から始まる整数）  
  - `array.length` : 要素数を返す  
  - 存在しないインデックスにアクセスすると `undefined` を返す  
  - **疎な配列** : 未定義の要素を含む配列  
  - **密な配列** : 全インデックスに要素がある配列  

  - 新しい配列メソッド
    - `Array.prototype.at(index)`  
      - 相対的なインデックスでアクセス可能  
      - `.at(-1)` → 末尾の要素  
    - `Array.isArray(obj)` : 配列かどうか判定  
    - `TypedArray` : 型付き配列（WebGLやバイナリデータ処理向け）  

- 配列の検索
  - `indexOf(value)` : 先頭から検索、見つからなければ -1  
  - `lastIndexOf(value)` : 末尾から検索  
  - `findIndex(callback)` : 条件に一致する最初のインデックスを返す  
  - `findLastIndex(callback)` [ES2023] : 条件に一致する最後のインデックスを返す  
  - `find(callback)` : 条件に一致する要素そのものを返す  
  - `findLast(callback)` [ES2023] : 条件に一致する最後の要素を返す  
  - `includes(value)` [ES2016] : 配列に要素が含まれているかを判定  
  - `some(callback)` : 条件に一致する要素があればtrue  

- 配列の追加・削除
  - `push` : 末尾に追加  
  - `pop` : 末尾から削除  
  - `unshift` : 先頭に追加  
  - `shift` : 先頭から削除  
  - `concat` : 配列を結合（非破壊的）  
  - Spread構文 `...array` : 配列を展開して結合  

  - splice
    - `splice(start, deleteCount, ...items)`  
      - 要素の削除・追加が可能  
      - 破壊的  

  - 配列の削除方法
    - `splice` で削除  
    - `array.length = 0` で全削除  
    - `array = []` で空配列を代入  

- 破壊的 / 非破壊的メソッド
  - **破壊的メソッド (Mutable Method)**: 元の配列を変更する  
  - **非破壊的メソッド (Immutable Method)**: 新しい配列を返す  

  | 破壊的メソッド | 非破壊的メソッド |
  |----------------|-----------------|
  | `array[index] = item` | `array.with(index, item)` [ES2023] |
  | `pop` | `array.slice(0, -1)` |
  | `push` | `[...array, item]` |
  | `splice` | `toSpliced` [ES2023] |
  | `reverse` | `toReversed` [ES2023] |
  | `sort` | `toSorted` [ES2023] |
  | `shift` | `array.slice(1)` |
  | `unshift` | `[item, ...array]` |

- 配列のコピー
  - `slice()` : コピーを返す（非破壊的）  
  - `concat()` : コピーを返す（非破壊的）  

- 配列の反復処理
  - `forEach(callback)` : 各要素に処理を実行  
  - `map(callback)` : 各要素を加工した新しい配列を返す  
  - `filter(callback)` : 条件を満たす要素だけを返す  
  - `reduce(callback, init)` : 累積値を返す（合計などに利用）  

- 配列の構造変換
  - `flat(depth)` [ES2019] : 多次元配列をフラット化  
  - `flatMap(callback)` [ES2019] : mapしてからflat(1)  

- 配列のグループ化
  - `Object.groupBy(array, callback)` : 条件ごとにグループ化したオブジェクトを返す  

- Array-likeオブジェクト
  - 配列のように見えるがメソッドを持たない  
  - `Array.from(arrayLike)` [ES2015] : Arrayに変換  

- メソッドチェーン
  - 配列メソッドの返り値に続けて別のメソッドを呼び出す書き方  

  ```js
  const result = [1, 2, 3, 4, 5]
      .filter(n => n % 2 === 0)
      .map(n => n * 10);
